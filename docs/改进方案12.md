ä¼˜åŒ–æ–¹æ¡ˆ

  æ–¹æ¡ˆ1: å¼•å…¥"å€™é€‰ç­”æ¡ˆæ± "æœºåˆ¶ (Candidate Pool)

  ç›®æ ‡: è§£å†³"éªŒè¯-æ‹’ç»-æ­»å¾ªç¯"é—®é¢˜

  å®ç°:
  # agent.py - æ–°å¢å€™é€‰æ± ç®¡ç†
  class CandidatePool:
      def __init__(self):
          self.candidates = []  # [(answer, confidence, sources)]
          self.rejected = []    # [(answer, reason)]
      
      def add_candidate(self, answer: str, confidence: float, sources: list):
          # å»é‡
          if not any(self._is_similar(answer, c[0]) for c in self.candidates):
              self.candidates.append((answer, confidence, sources))
              self.candidates.sort(key=lambda x: x[1], reverse=True)

      def reject(self, answer: str, reason: str):
          self.rejected.append((answer, reason))
          # ä»å€™é€‰æ± ç§»é™¤
          self.candidates = [c for c in self.candidates
                            if not self._is_similar(answer, c[0])]

      def get_next_best(self) -> Optional[str]:
          """è¿”å›ä¸‹ä¸€ä¸ªæœªå°è¯•çš„æœ€é«˜åˆ†å€™é€‰"""
          for ans, conf, _ in self.candidates:
              if not any(self._is_similar(ans, r[0]) for r in self.rejected):
                  return ans
          return None

      def _is_similar(self, a: str, b: str) -> bool:
          from difflib import SequenceMatcher
          return SequenceMatcher(None, a.lower(), b.lower()).ratio() > 0.8

  # ä¿®æ”¹ agent.py:query å‡½æ•°
  async def query(req: QueryRequest) -> QueryResponse:
      candidate_pool = CandidatePool()
      MAX_RETRIES = 2

      for attempt in range(MAX_RETRIES + 1):
          # ...æ‰§è¡Œ agent_loop...

          # æ”¶é›†å€™é€‰ç­”æ¡ˆ(ä»æœç´¢ç»“æœ/LLMè¾“å‡ºæå–)
          # (æ–°å¢é€»è¾‘:åœ¨agent_loopè¿”å›å‰,ä»metaä¸­æå–æ‰€æœ‰å€™é€‰)
          candidates_from_search = (state.get("meta") or {}).get("candidates", [])        
          for cand in candidates_from_search:
              candidate_pool.add_candidate(cand["text"], cand["confidence"],
  cand["sources"])

          result = clean_answer(result)
          verified = verify_answer(req.question, result)

          if "[REJECTED]" in verified:
              candidate_pool.reject(result, verified)

              # âœ… å…³é”®æ”¹è¿›:å°è¯•ä¸‹ä¸€ä¸ªå€™é€‰,è€Œä¸æ˜¯ç›²ç›®é‡è¯•
              next_candidate = candidate_pool.get_next_best()
              if next_candidate:
                  print(f"[CandidatePool] Trying next candidate: {next_candidate}")       
                  # è·³è¿‡agent_loop,ç›´æ¥éªŒè¯ä¸‹ä¸€ä¸ªå€™é€‰
                  result = next_candidate
                  continue  # é‡æ–°éªŒè¯
              else:
                  # æ‰€æœ‰å€™é€‰éƒ½è¢«æ‹’ç»,æ‰çœŸæ­£é‡è¯•
                  rejection_history.append(...)
                  # å¼ºåˆ¶è¦æ±‚Agent"æ¢å›½å®¶æœç´¢"
                  messages.append({
                      "role": "system",
                      "content": f"[CRITICAL] All {len(candidate_pool.rejected)}
  candidates rejected. You MUST search for a DIFFERENT country/person. Do NOT repeat:     
  {[r[0] for r in candidate_pool.rejected]}"
                  })

  æ•ˆæœ:
  - é¿å…åœ¨åŒä¸€é”™è¯¯ç­”æ¡ˆä¸Šåå¤éªŒè¯
  - å¦‚æœæœ‰3ä¸ªå€™é€‰(KhÃ¼relsÃ¼kh, Oyun-Erdene, Isakov),ä¼šä¾æ¬¡éªŒè¯,è€Œä¸æ˜¯é‡æ–°æœç´¢

  ---
  æ–¹æ¡ˆ2: Plannerå¢å¼º - Plan Validator + Execution Tracker

  ç›®æ ‡: è§£å†³Planæ‰§è¡Œåå·®é—®é¢˜

  å®ç°:
  # agent_loop.py - æ–°å¢PlanéªŒè¯å™¨
  def validate_plan(plan: str, rejection_context: str = "") -> dict:
      """éªŒè¯Plançš„ä¸€è‡´æ€§å’Œå¯æ‰§è¡Œæ€§"""
      client = _get_llm_client()

      validator_prompt = [{
          "role": "system",
          "content": """You are a Plan Validator. Check if the plan has:
  1. **Contradictions**: e.g., Step 2 says "focus on Mongolia", Step 8 says "exclude      
  Mongolia"
  2. **Missing Critical Steps**: e.g., forgot to verify education background
  3. **Redundant Steps**: e.g., same search repeated in Step 3 and Step 5
  4. **Unrealistic Constraints**: e.g., "-Mongolia" in search when Mongolia is the only   
  candidate

  Output JSON:
  {
    "is_valid": true/false,
    "issues": ["issue1", "issue2"],
    "fixed_plan": "corrected plan text (if invalid)"
  }"""
      }, {
          "role": "user",
          "content": f"Plan:\n{plan}\n\nRejection Context:\n{rejection_context}"
      }]

      resp = client.chat.completions.create(
          model="qwen3-max",
          messages=validator_prompt,
          response_format={"type": "json_object"}
      )

      return json.loads(resp.choices[0].message.content)

  # åœ¨Plannerç”Ÿæˆåç«‹å³éªŒè¯
  # agent_loop.py:751-765
  try:
      plan = plan_resp.choices[0].message.content

      # âœ… æ–°å¢éªŒè¯æ­¥éª¤
      validation = validate_plan(plan, rejection_context)
      if not validation["is_valid"]:
          print(f"[Planner] Planæœ‰çŸ›ç›¾: {validation['issues']}")
          plan = validation["fixed_plan"]  # ä½¿ç”¨ä¿®æ­£åçš„Plan

      system_prompt_addition += f"\n\n### ğŸ“‹ CURRENT PLAN\n{plan}\n..."

  æ–°å¢Plan Execution Tracker:
  # agent_loop.py:state ä¸­æ–°å¢å­—æ®µ
  state = {
      "messages": ...,
      "meta": {
          "plan_steps": [],  # ä»Planè§£æå‡ºçš„æ­¥éª¤åˆ—è¡¨
          "completed_steps": [],  # å·²å®Œæˆçš„æ­¥éª¤
          "current_step": 0
      }
  }

  # åœ¨execute_toolsåæ£€æŸ¥è¿›åº¦
  def check_plan_progress(state: dict) -> dict:
      """æ£€æŸ¥å½“å‰æ˜¯å¦æŒ‰Planæ‰§è¡Œ"""
      meta = state.get("meta", {})
      plan_steps = meta.get("plan_steps", [])
      current_step = meta.get("current_step", 0)
      
      if current_step >= len(plan_steps):
          return state

      expected_action = plan_steps[current_step]
      last_tool_call = state["messages"][-2] if len(state["messages"]) >= 2 else {}       
      actual_tool = last_tool_call.get("tool_calls", [{}])[0].get("function",
  {}).get("name")

      # å¦‚æœæ‰§è¡Œçš„å·¥å…·ä¸Planä¸ç¬¦,å‘å‡ºè­¦å‘Š
      if expected_action["type"] == "search" and actual_tool != "web_search":
          state["messages"].append({
              "role": "system",
              "content": f"[Plan Deviation] Expected: {expected_action['action']}, but you
   called: {actual_tool}"
          })

      meta["current_step"] += 1
      return state

  ---
  æ–¹æ¡ˆ3: æœç´¢æŸ¥è¯¢çš„"è¯­è¨€ä¸€è‡´æ€§"ä¿®å¤

  ç›®æ ‡: é¿å…ä¸­è‹±æ··æ‚æŸ¥è¯¢

  å®ç°:
  # agent.py - æ–°å¢æŸ¥è¯¢è¯­è¨€æ£€æµ‹ä¸ç¿»è¯‘
  def ensure_query_language_consistency(query: str) -> str:
      """ç¡®ä¿æŸ¥è¯¢è¯­è¨€ä¸€è‡´(å…¨è‹±æ–‡æˆ–å…¨ä¸­æ–‡)"""
      import re

      # æ£€æµ‹ä¸»è¦è¯­è¨€
      has_chinese = bool(re.search(r'[\u4e00-\u9fff]', query))
      has_english = bool(re.search(r'[a-zA-Z]{3,}', query))

      # å¦‚æœæ··æ‚,ç»Ÿä¸€ä¸ºè‹±æ–‡(æœç´¢å¼•æ“å‹å¥½)
      if has_chinese and has_english:
          # æ›¿æ¢å¸¸è§ä¸­æ–‡æ•æ„Ÿè¯ä¸ºè‹±æ–‡
          replacements = {
              "äº‹ä»¶": "incident",
              "ç›¸å…³è°ƒæŸ¥": "investigation",
              "æ ¸æŸ¥": "review",
              "å®¶åº­èƒŒæ™¯": "family background",
              "ä¸‘é—»": "controversy",
              "è…è´¥": "corruption"
          }
          for cn, en in replacements.items():
              query = query.replace(cn, en)

      return query

  # åœ¨web_searchè°ƒç”¨å‰è‡ªåŠ¨ä¿®æ­£
  # agent_loop.py:1102è¡Œ
  if func_name == "web_search":
      # âœ… æ–°å¢æŸ¥è¯¢ä¿®æ­£
      original_query = str(parsed_args.get("query") or "")
      fixed_query = ensure_query_language_consistency(original_query)
      if fixed_query != original_query:
          print(f"[QueryFix] '{original_query}' â†’ '{fixed_query}'")
          parsed_args["query"] = fixed_query

  ---
  æ–¹æ¡ˆ4: Skillè¾“å‡ºçš„"è´¨é‡é—¨æ§"

  ç›®æ ‡: é¿å…ä½è´¨é‡SkillæŸ¥è¯¢æµªè´¹æœç´¢é…é¢

  å®ç°:
  # agent_loop.py:1152-1161 ä¿®æ”¹
  if "optimized_queries" in skill_output:
      queries = skill_output["optimized_queries"]

      # âœ… æ–°å¢è´¨é‡æ£€æŸ¥
      valid_queries = []
      for q in queries:
          # è¿‡æ»¤è¿‡çŸ­æŸ¥è¯¢
          if len(q.strip()) < 10:
              print(f"[SkillQC] Rejected too-short query: '{q}'")
              continue

          # è¿‡æ»¤åªæœ‰é€šç”¨è¯çš„æŸ¥è¯¢
          generic_only = all(word.lower() in {"list", "of", "the", "and", "or", "in"}     
                            for word in q.split())
          if generic_only:
              print(f"[SkillQC] Rejected generic-only query: '{q}'")
              continue

          valid_queries.append(q)

      if not valid_queries:
          # Skillå¤±è´¥,ä½¿ç”¨fallback
          print("[SkillQC] All Skill queries rejected. Using fallback.")
          # è§¦å‘fallbacké€»è¾‘(å·²æœ‰ä»£ç 1250-1273)
      else:
          hint = f"[System Enforced]: Use these {len(valid_queries)} verified queries:\n" 
          for i, q in enumerate(valid_queries, 1):
              hint += f"  {i}. {q}\n"
          tool_result_content += hint

  ---
  æ–¹æ¡ˆ5: Web Fetchçš„"åŸŸåé»‘åå• + å¿«é€Ÿå¤±è´¥"

  ç›®æ ‡: é¿å…åœ¨å·²çŸ¥ä¼šè¶…æ—¶çš„åŸŸåä¸Šæµªè´¹æ—¶é—´

  å®ç°:
  # agent.py - æ–°å¢åŸŸåé»‘åå•
  _KNOWN_TIMEOUT_DOMAINS = {
      "www.cia.gov",
      "www.state.gov",
      # å¯åŠ¨æ€æ›´æ–°
  }

  def web_fetch(url: str, max_bytes: int = 200_000) -> str:
      try:
          parsed = urllib.parse.urlparse(url)
          domain = parsed.netloc

          # âœ… å¿«é€Ÿå¤±è´¥
          if domain in _KNOWN_TIMEOUT_DOMAINS:
              print(f"[WebFetch] Domain {domain} in blacklist. Skip fetch, try snippet    
  fallback.")
              # ç›´æ¥è§¦å‘snippet fallback
              raise TimeoutError(f"Domain {domain} known to timeout")
          
          # åŸæœ‰é€»è¾‘...
          
      except TimeoutError as e:
          # è®°å½•åˆ°é»‘åå•(æŒä¹…åŒ–åˆ°æ–‡ä»¶)
          _KNOWN_TIMEOUT_DOMAINS.add(domain)

          # è§¦å‘snippet fallback
          # (å·²æœ‰ä»£ç 1206-1230)

  ---
  æ–¹æ¡ˆ6: Reflexionçš„"ç­–ç•¥åˆ‡æ¢"è§¦å‘å™¨

  ç›®æ ‡: é¿å…æ­»å¾ªç¯æœç´¢åŒä¸€ä¸ªå®ä½“

  å®ç°:
  # agent_loop.py:1370-1403 å¢å¼ºReflexion
  # æ£€æµ‹åˆ°è¿ç»­3æ¬¡æœç´¢åŒä¸€å®ä½“æ—¶,å¼ºåˆ¶åˆ‡æ¢
  if search_count < 10:
      # æ£€æµ‹ä¸»å¯¼å®ä½“
      from collections import Counter
      entity_freq = Counter()
      for kw in searched_kws:
          for ent in ents:  # entsæ˜¯æå–çš„æ ¸å¿ƒå®ä½“
              if ent.lower() in kw.lower():
                  entity_freq[ent] += 1

      # å¦‚æœæŸä¸ªå®ä½“å‡ºç°>50%æ¬¡æ•°
      dominant_entity = entity_freq.most_common(1)
      if dominant_entity and dominant_entity[0][1] > search_count * 0.5:
          stuck_entity = dominant_entity[0][0]
          reflexion_msg = f"""Reflexion: [Strategy Switch Enforced]
  ä½ åœ¨ {search_count} æ¬¡æœç´¢ä¸­,æœ‰ {dominant_entity[0][1]} æ¬¡éƒ½åœ¨æœç´¢ "{stuck_entity}".    

  âš ï¸ MANDATORY ACTION:
  1. STOP searching for "{stuck_entity}"
  2. SWITCH to a DIFFERENT candidate country/person immediately
  3. Use excluded_entities=["{stuck_entity}"] in smart-search
  4. If you believe "{stuck_entity}" is the only answer, provide EXPLICIT evidence for ALL
   constraints (education, scandal type, timeline)
  """
          needs_reflexion = True

  ---
  æ€»ç»“ä¸ä¼˜å…ˆçº§
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ ä¼˜å…ˆçº§ â”‚        æ–¹æ¡ˆ        â”‚      è§£å†³çš„æ ¸å¿ƒé—®é¢˜       â”‚ é¢„è®¡å¼€å‘é‡ â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ P0     â”‚ å€™é€‰ç­”æ¡ˆæ±          â”‚ é¿å…é‡å¤éªŒè¯åŒä¸€é”™è¯¯ç­”æ¡ˆ  â”‚ 2å°æ—¶      â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ P0     â”‚ æŸ¥è¯¢è¯­è¨€ä¸€è‡´æ€§ä¿®å¤ â”‚ ä¿®å¤ä¸­è‹±æ··æ‚å¯¼è‡´æœç´¢å¤±æ•ˆ  â”‚ 30åˆ†é’Ÿ     â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ P1     â”‚ Plan Validator     â”‚ æ£€æµ‹PlançŸ›ç›¾,å‡å°‘æ‰§è¡Œåå·® â”‚ 1.5å°æ—¶    â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ P1     â”‚ åŸŸåé»‘åå•         â”‚ é¿å…è¶…æ—¶æµªè´¹,æå‡æ•ˆç‡     â”‚ 30åˆ†é’Ÿ     â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ P2     â”‚ Skillè´¨é‡é—¨æ§      â”‚ è¿‡æ»¤ä½è´¨é‡æŸ¥è¯¢            â”‚ 1å°æ—¶      â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ P2     â”‚ Reflexionç­–ç•¥åˆ‡æ¢  â”‚ å¼ºåˆ¶è·³å‡ºæ­»å¾ªç¯            â”‚ 1å°æ—¶      â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  ç«‹å³å®æ–½: P0æ–¹æ¡ˆ(å€™é€‰æ±  + è¯­è¨€ä¿®å¤)
  ä¸‹ä¸€æ­¥: P1æ–¹æ¡ˆ(PlanéªŒè¯ + é»‘åå•)